// functions
export function assertEqual(val) {
    return val;
}
export function assertNotEqual(val) {
    return val;
}
export function assertIs(_arg) { }
export function assertNever(_x) {
    throw new Error();
}
export function assert(_) { }
export function getValidEnumValues(obj) {
    const validKeys = Object.keys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
        filtered[k] = obj[k];
    }
    return Object.values(filtered);
}
export function joinValues(array, separator = "|") {
    return array.map((val) => stringifyPrimitive(val)).join(separator);
}
export function jsonStringifyReplacer(_, value) {
    if (typeof value === "bigint")
        return value.toString();
    return value;
}
export function cached(getter) {
    const set = false;
    return {
        get value() {
            if (!set) {
                const value = getter();
                Object.defineProperty(this, "value", { value });
                return value;
            }
            throw new Error("cached value already set");
        },
    };
}
export function nullish(input) {
    return input === null || input === undefined;
}
export function cleanRegex(source) {
    const start = source.startsWith("^") ? 1 : 0;
    const end = source.endsWith("$") ? source.length - 1 : source.length;
    return source.slice(start, end);
}
export function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
    return (valInt % stepInt) / 10 ** decCount;
}
export function defineLazy(object, key, getter) {
    const set = false;
    Object.defineProperty(object, key, {
        get() {
            if (!set) {
                const value = getter();
                object[key] = value;
                // Object.defineProperty(object, key, { value });
                return value;
            }
            throw new Error("cached value already set");
        },
        set(v) {
            Object.defineProperty(object, key, {
                value: v,
                // configurable: true,
            });
            // object[key] = v;
        },
        configurable: true,
    });
}
export function assignProp(target, prop, value) {
    Object.defineProperty(target, prop, {
        value,
        writable: true,
        enumerable: true,
        configurable: true,
    });
}
export function getElementAtPath(obj, path) {
    if (!path)
        return obj;
    return path.reduce((acc, key) => acc?.[key], obj);
}
export function promiseAllObject(promisesObj) {
    const keys = Object.keys(promisesObj);
    const promises = keys.map((key) => promisesObj[key]);
    return Promise.all(promises).then((results) => {
        const resolvedObj = {};
        for (let i = 0; i < keys.length; i++) {
            resolvedObj[keys[i]] = results[i];
        }
        return resolvedObj;
    });
}
export function randomString(length = 10) {
    const chars = "abcdefghijklmnopqrstuvwxyz";
    let str = "";
    for (let i = 0; i < length; i++) {
        str += chars[Math.floor(Math.random() * chars.length)];
    }
    return str;
}
export function esc(str) {
    return JSON.stringify(str);
}
export function isObject(data) {
    return typeof data === "object" && data !== null;
}
export const allowsEval = cached(() => {
    try {
        new Function("");
        return true;
    }
    catch (_) {
        return false;
    }
});
export function isPlainObject(data) {
    return typeof data === "object" && data !== null && Object.getPrototypeOf(data) === Object.prototype;
}
export function numKeys(data) {
    let keyCount = 0;
    for (const key in data) {
        if (Object.prototype.hasOwnProperty.call(data, key)) {
            keyCount++;
        }
    }
    return keyCount;
}
export const getParsedType = (data) => {
    const t = typeof data;
    switch (t) {
        case "undefined":
            return "undefined";
        case "string":
            return "string";
        case "number":
            return Number.isNaN(data) ? "nan" : "number";
        case "boolean":
            return "boolean";
        case "function":
            return "function";
        case "bigint":
            return "bigint";
        case "symbol":
            return "symbol";
        case "object":
            if (Array.isArray(data)) {
                return "array";
            }
            if (data === null) {
                return "null";
            }
            if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
                return "promise";
            }
            if (typeof Map !== "undefined" && data instanceof Map) {
                return "map";
            }
            if (typeof Set !== "undefined" && data instanceof Set) {
                return "set";
            }
            if (typeof Date !== "undefined" && data instanceof Date) {
                return "date";
            }
            if (typeof File !== "undefined" && data instanceof File) {
                return "file";
            }
            return "object";
        default:
            throw new Error(`Unknown data type: ${t}`);
    }
};
export const propertyKeyTypes = new Set(["string", "number", "symbol"]);
export const primitiveTypes = new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
export function escapeRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
// zod-specific utils
export function clone(inst, def) {
    return new inst._zod.constr(def);
}
export function splitChecksAndParams(_paramsOrChecks, _checks) {
    const params = (Array.isArray(_paramsOrChecks) ? {} : (_paramsOrChecks ?? {}));
    const checks = Array.isArray(_paramsOrChecks) ? _paramsOrChecks : (_checks ?? []);
    return {
        checks,
        params,
    };
}
export function normalizeParams(_params) {
    const params = _params;
    if (!params)
        return {};
    if (typeof params === "string")
        return { error: () => params };
    if (params?.message !== undefined) {
        if (params?.error !== undefined)
            throw new Error("Cannot specify both `message` and `error` params");
        params.error = params.message;
    }
    delete params.message;
    if (typeof params.error === "string")
        return { ...params, error: () => params.error };
    return params;
}
export function createTransparentProxy(getter) {
    let target;
    return new Proxy({}, {
        get(_, prop, receiver) {
            target ?? (target = getter());
            return Reflect.get(target, prop, receiver);
        },
        set(_, prop, value, receiver) {
            target ?? (target = getter());
            return Reflect.set(target, prop, value, receiver);
        },
        has(_, prop) {
            target ?? (target = getter());
            return Reflect.has(target, prop);
        },
        deleteProperty(_, prop) {
            target ?? (target = getter());
            return Reflect.deleteProperty(target, prop);
        },
        ownKeys(_) {
            target ?? (target = getter());
            return Reflect.ownKeys(target);
        },
        getOwnPropertyDescriptor(_, prop) {
            target ?? (target = getter());
            return Reflect.getOwnPropertyDescriptor(target, prop);
        },
        defineProperty(_, prop, descriptor) {
            target ?? (target = getter());
            return Reflect.defineProperty(target, prop, descriptor);
        },
        // apply(target, thisArg, args) {
        //   return Reflect.apply(target, thisArg, args);
        // },
        // construct(target, args, newTarget) {
        //   return Reflect.construct(target, args, newTarget);
        // },
    });
}
export function stringifyPrimitive(value) {
    if (typeof value === "bigint")
        return value.toString() + "n";
    if (typeof value === "string")
        return `"${value}"`;
    return `${value}`;
}
export function optionalObjectKeys(shape) {
    return Object.keys(shape).filter((k) => {
        return shape[k]._zod.qout === "true";
    });
}
export function optionalInterfaceKeys(shape) {
    return Object.keys(shape)
        .filter((k) => {
        return k.endsWith("?");
    })
        .map((k) => k.replace(/\?$/, ""));
}
export function cleanInterfaceKey(key) {
    return key.replace(/^\?/, "").replace(/\?$/, "");
}
export function cleanInterfaceShape(_shape) {
    const keyMap = {};
    const shape = {};
    const optional = [];
    const defaulted = [];
    for (const [key, value] of Object.entries(_shape)) {
        if (key.endsWith("?"))
            optional.push(key.slice(0, -1));
        if (key.startsWith("?"))
            defaulted.push(key.slice(1));
        const cleanKey = cleanInterfaceKey(key);
        shape[cleanKey] = value;
        keyMap[cleanKey] = key;
    }
    return { shape, keyMap, optional, defaulted };
}
export const NUMBER_FORMAT_RANGES = {
    safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
    int32: [-2147483648, 2147483647],
    uint32: [0, 4294967295],
    float32: [-3.4028234663852886e38, 3.4028234663852886e38],
    float64: [-1.7976931348623157e308, 1.7976931348623157e308],
};
export const BIGINT_FORMAT_RANGES = {
    int64: [/* @__PURE__*/ BigInt("-9223372036854775808"), /* @__PURE__*/ BigInt("9223372036854775807")],
    uint64: [/* @__PURE__*/ BigInt(0), /* @__PURE__*/ BigInt("18446744073709551615")],
};
export function pick(schema, mask) {
    const newShape = {};
    const newOptional = [];
    const currShape = schema._zod.def.shape;
    const currOptional = new Set(schema._zod.def.optional);
    // const currDefaulted = new Set(schema._zod.def.defaulted);
    for (const key in mask) {
        if (!(key in currShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
            continue;
        // pick key
        newShape[key] = currShape[key];
        if (currOptional.has(key)) {
            newOptional.push(key);
        }
    }
    return clone(schema, {
        ...schema._zod.def,
        shape: newShape,
        optional: newOptional,
        checks: [],
    });
}
export function omit(schema, mask) {
    const newShape = { ...schema._zod.def.shape };
    const newOptional = new Set(schema._zod.def.optional);
    for (const key in mask) {
        if (!(key in schema._zod.def.shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
            continue;
        delete newShape[key];
        newOptional.delete(key);
    }
    return clone(schema, {
        ...schema._zod.def,
        shape: newShape,
        optional: [...newOptional],
        checks: [],
    });
}
export function extend(schema, shape) {
    const def = {
        ...schema._zod.def,
        get shape() {
            const _shape = { ...schema._zod.def.shape, ...shape };
            assignProp(this, "shape", _shape);
            return _shape;
        },
        checks: [], // delete existing checks
    };
    defineLazy(def, "shape", () => ({ ...schema._zod.def.shape, ...shape }));
    return clone(schema, def);
}
export function mergeObjectLike(a, b) {
    const bKeys = new Set(Object.keys(b._zod.def.shape));
    const optional = [...a._zod.def.optional.filter((k) => !bKeys.has(k)), ...b._zod.def.optional];
    return clone(a, {
        ...a._zod.def,
        get shape() {
            const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
            assignProp(this, "shape", _shape);
            return _shape;
            // return { ...a._zod.def.shape, ...b._zod.def.shape };
        },
        optional,
        catchall: b._zod.def.catchall,
        checks: [], // delete existing checks
    });
}
export function extendObjectLike(a, b) {
    const bKeys = new Set(Object.keys(b._zod.def.shape));
    const optional = [...a._zod.def.optional.filter((k) => !bKeys.has(k)), ...b._zod.def.optional];
    return clone(a, {
        ...a._zod.def,
        get shape() {
            const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
            assignProp(this, "shape", _shape);
            return _shape;
            // return { ...a._zod.def.shape, ...b._zod.def.shape };
        },
        optional,
        checks: [], // delete existent checks
    });
}
export function partialObjectLike(Class, schema, mask) {
    const shape = { ...schema._zod.def.shape };
    const optional = new Set(schema._zod.def.optional);
    if (mask) {
        for (const key in mask) {
            if (!(key in shape)) {
                throw new Error(`Unrecognized key: "${key}"`);
            }
            if (!mask[key])
                continue;
            shape[key] = new Class({
                type: "optional",
                innerType: schema._zod.def.shape[key],
            });
            optional.add(key);
        }
    }
    else {
        for (const key in schema._zod.def.shape) {
            shape[key] = new Class({
                type: "optional",
                innerType: schema._zod.def.shape[key],
            });
            optional.add(key);
        }
    }
    return clone(schema, {
        ...schema._zod.def,
        shape,
        optional: [...optional],
        checks: [],
    });
}
export function requiredObjectLike(Class, schema, mask) {
    const shape = { ...schema._zod.def.shape };
    if (mask) {
        for (const key in mask) {
            if (!(key in shape)) {
                throw new Error(`Unrecognized key: "${key}"`);
            }
            if (!mask[key])
                continue;
            // overwrite with non-optional
            shape[key] = new Class({
                type: "nonoptional",
                innerType: schema._zod.def.shape[key],
            });
        }
    }
    else {
        for (const key in schema._zod.def.shape) {
            // overwrite with non-optional
            shape[key] = new Class({
                type: "nonoptional",
                innerType: schema._zod.def.shape[key],
            });
        }
    }
    return clone(schema, {
        ...schema._zod.def,
        shape,
        optional: [],
        checks: [],
    });
}
export function normalizeObjectLikeDef(def) {
    if (def.type === "interface") {
        const keys = Object.keys(def.shape);
        const keySet = new Set(Object.keys(def.shape));
        return {
            shape: { ...def.shape }, // resolve getters
            keys,
            keySet,
            numKeys: keys.length,
            optionalKeys: new Set(def.optional),
        };
    }
    if (def.type === "object") {
        const keys = Object.keys(def.shape);
        const keySet = new Set(Object.keys(def.shape));
        return {
            shape: { ...def.shape }, // resolve getters
            keys,
            keySet,
            numKeys: keys.length,
            optionalKeys: new Set(def.optional),
        };
    }
    throw new Error("Invalid object-like type");
}
export function aborted(x, startIndex = 0) {
    for (let i = startIndex; i < x.issues.length; i++) {
        if (x.issues[i].continue !== true)
            return true;
    }
    return false;
}
export function prefixIssues(path, issues) {
    return issues.map((iss) => {
        var _a;
        (_a = iss).path ?? (_a.path = []);
        iss.path.unshift(path);
        return iss;
    });
}
export function unwrapMessage(message) {
    return typeof message === "string" ? message : message?.message;
}
export function finalizeIssue(iss, ctx, config) {
    const full = { ...iss, path: iss.path ?? [] };
    // for backwards compatibility
    // const _ctx: errors.$ZodErrorMapCtx = { data: iss.input, defaultError: undefined as any };
    if (!iss.message) {
        const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ??
            unwrapMessage(ctx?.error?.(iss)) ??
            unwrapMessage(config.customError?.(iss)) ??
            unwrapMessage(config.localeError?.(iss)) ??
            "Invalid input";
        full.message = message;
    }
    // delete (full as any).def;
    delete full.inst;
    delete full.continue;
    if (!ctx?.reportInput) {
        delete full.input;
    }
    return full;
}
export function getSizableOrigin(input) {
    if (input instanceof Set)
        return "set";
    if (input instanceof Map)
        return "map";
    if (input instanceof File)
        return "file";
    return "unknown";
}
export function getLengthableOrigin(input) {
    if (Array.isArray(input))
        return "array";
    if (typeof input === "string")
        return "string";
    return "unknown";
}
export function issue(...args) {
    const [iss, input, inst] = args;
    if (typeof iss === "string") {
        return {
            message: iss,
            code: "custom",
            input,
            inst,
        };
    }
    return { ...iss };
}
